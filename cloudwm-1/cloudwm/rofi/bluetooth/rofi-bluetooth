#!/usr/bin/env bash
#              *       *     *            *              *   *
#  * * / ()     | | | |_   *  *| | __    | || |
# | '/ * \| |*| |___| ' \| | | | |/ * \ */ * \ / * \| | ' \
# | | | () |  | |__| |) | | || |  / || () | () | || | | |
# ||  \_/|| ||     |.__/||\,_|\_|\\_/ \__/ \_|| ||
#
# Author: Nick Clyde (clydedroid)
#
# A script that generates a rofi menu that uses bluetoothctl to
# connect to bluetooth devices and display status info.
#
# Inspired by networkmanager-dmenu (https://github.com/firecat53/networkmanager-dmenu)
# Thanks to x70b1 (https://github.com/polybar/polybar-scripts/tree/master/polybar-scripts/system-bluetooth-bluetoothctl)
#
# Depends on:
#   Arch repositories: rofi, bluez-utils (contains bluetoothctl), bc

# Constants
divider="───────────────────────────────────────────────"
goback="Back"

# Set rofi command based on scan state and power state
set_rofi_command() {
    if bluetoothctl show | grep -q "Discovering: yes"; then
        rofi_command="rofi -dmenu -theme ~/cloudwm/rofi/bluetooth/bluetooth-scan.rasi $* -p"
    elif power_on; then
        # Normal powered-on state - up to 6 lines
        rofi_command="rofi -dmenu -theme ~/cloudwm/rofi/bluetooth/bluetooth.rasi -lines 6 -fixed-num-lines $* -p"
    else
        # Power off state - use separate theme with 2 lines
        rofi_command="rofi -dmenu -theme ~/cloudwm/rofi/bluetooth/bluetooth-power-off.rasi -lines 2 -fixed-num-lines $* -p"
    fi
}

# Checks if bluetooth controller is powered on
power_on() {
    if bluetoothctl show | grep -q "Powered: yes"; then
        return 0
    else
        return 1
    fi
}

# Toggles power state
toggle_power() {
    if power_on; then
        bluetoothctl power off
        # Wait a moment for the power off to process
        sleep 1
        # Check if power off was successful
        if ! power_on; then
            notify-send "Bluetooth Connection Status" "Bluetooth Interface Off" --icon=bluetooth-disabled
        else
            notify-send "Bluetooth Connection Status" "Failed to turn off Bluetooth interface" --icon=bluetooth-disabled
        fi
    else
        if rfkill list bluetooth | grep -q 'blocked: yes'; then
            rfkill unblock bluetooth && sleep 3
        fi
        bluetoothctl power on
        # Wait a moment for the power on to process
        sleep 2
        # Check if power on was successful
        if power_on; then
            notify-send "Bluetooth Connection Status" "Bluetooth Interface On" --icon=bluetooth-active
        else
            notify-send "Bluetooth Connection Status" "Failed to turn on Bluetooth interface" --icon=bluetooth-disabled
        fi
    fi
}

# Checks if controller is scanning for new devices
scan_on() {
    if bluetoothctl show | grep -q "Discovering: yes"; then
        echo "Scan: on"
        return 0
    else
        echo "Scan: off"
        return 1
    fi
}

# Toggles scanning state
toggle_scan() {
    if scan_on; then
        kill $(pgrep -f "bluetoothctl --timeout 5 scan on") 2>/dev/null
        bluetoothctl scan off
    else
        bluetoothctl --timeout 5 scan on &
        echo "Scanning..."
        sleep 2
    fi
}

# Checks if controller is able to pair to devices
pairable_on() {
    if bluetoothctl show | grep -q "Pairable: yes"; then
        echo "Pairable: on"
        return 0
    else
        echo "Pairable: off"
        return 1
    fi
}

# Toggles pairable state
toggle_pairable() {
    if pairable_on; then
        bluetoothctl pairable off
    else
        bluetoothctl pairable on
    fi
}

# Checks if controller is discoverable by other devices
discoverable_on() {
    if bluetoothctl show | grep -q "Discoverable: yes"; then
        echo "Discoverable: on"
        return 0
    else
        echo "Discoverable: off"
        return 1
    fi
}

# Toggles discoverable state
toggle_discoverable() {
    if discoverable_on; then
        bluetoothctl discoverable off
    else
        bluetoothctl discoverable on
    fi
}

# Checks if a device is connected
device_connected() {
    device_info=$(bluetoothctl info "$1")
    if echo "$device_info" | grep -q "Connected: yes"; then
        return 0
    else
        return 1
    fi
}

# Toggles device connection
toggle_connection() {
    local mac="$1"
    local device_name=$(bluetoothctl info "$mac" | grep "Alias" | cut -d ' ' -f 2-)
    
    if device_connected "$mac"; then
        bluetoothctl disconnect "$mac"
        # Wait a moment for the disconnection to process
        sleep 1
        # Check if disconnection was successful
        if ! device_connected "$mac"; then
            notify-send "Bluetooth Connection Status" "Disconnected from $device_name" --icon=bluetooth-disabled
        else
            notify-send "Bluetooth Connection Status" "Failed to disconnect from $device_name" --icon=bluetooth-disabled
        fi
    else
        bluetoothctl connect "$mac"
        # Wait a moment for the connection to process
        sleep 2
        # Check if connection was successful
        if device_connected "$mac"; then
            notify-send "Bluetooth Connection Status" "Connected to $device_name" --icon=bluetooth-active
        else
            notify-send "Bluetooth Connection Status" "Failed to connect to $device_name" --icon=bluetooth-disabled
        fi
    fi
}

# Checks if a device is paired
device_paired() {
    device_info=$(bluetoothctl info "$1")
    if echo "$device_info" | grep -q "Paired: yes"; then
        echo "Paired: yes"
        return 0
    else
        echo "Paired: no"
        return 1
    fi
}

# Toggles device paired state
toggle_paired() {
    if device_paired "$1"; then
        bluetoothctl remove "$1"
    else
        bluetoothctl pair "$1"
    fi
}

# Checks if a device is trusted
device_trusted() {
    device_info=$(bluetoothctl info "$1")
    if echo "$device_info" | grep -q "Trusted: yes"; then
        echo "Trusted: yes"
        return 0
    else
        echo "Trusted: no"
        return 1
    fi
}

# Toggles device trust state
toggle_trust() {
    if device_trusted "$1"; then
        bluetoothctl untrust "$1"
    else
        bluetoothctl trust "$1"
    fi
}

# Prints a short string with the current bluetooth status
# Useful for status bars like polybar, etc.
print_status() {
    if power_on; then
        printf ''
        paired_devices_cmd="devices Paired"
        # Check if an outdated version of bluetoothctl is used to preserve backwards compatibility
        if (( $(echo "$(bluetoothctl version | cut -d ' ' -f 2) < 5.65" | bc -l) )); then
            paired_devices_cmd="paired-devices"
        fi
        mapfile -t paired_devices < <(bluetoothctl $paired_devices_cmd | grep Device | cut -d ' ' -f 2)
        counter=0
        for device in "${paired_devices[@]}"; do
            if device_connected "$device"; then
                device_alias=$(bluetoothctl info "$device" | grep "Alias" | cut -d ' ' -f 2-)
                if [ $counter -gt 0 ]; then
                    printf ", %s" "$device_alias"
                else
                    printf " %s" "$device_alias"
                fi
                ((counter++))
            fi
        done
        printf "\n"
    else
        echo ""
    fi
}

# A submenu for a specific device that allows connecting, pairing, and trusting
device_menu() {
    local device=$1
    local current_menu="device"
    
    while [[ $current_menu == "device" ]]; do
        # Set specific rofi command for device menu with 5 lines
        rofi_command="rofi -dmenu -theme ~/.config/rofi/styles/bluetooth-device.rasi -lines 5 -fixed-num-lines $* -p"
        
        # Get device name and mac address
        device_name=$(echo "$device" | cut -d ' ' -f 3-)
        mac=$(echo "$device" | cut -d ' ' -f 2)
        
        # Build options
        if device_connected "$mac"; then
            connected="Connected: yes"
        else
            connected="Connected: no"
        fi
        paired=$(device_paired "$mac")
        trusted=$(device_trusted "$mac")
        options="$connected\n$paired\n$trusted" #\n$divider\n$goback
        
        # Open rofi menu, read chosen option
        chosen="$(echo -e "$options" | $rofi_command "Bluetooth Device: $device_name")"
        
        # Match chosen option to command
        case "$chosen" in
            "" | "$divider")
                # Empty selection (Escape key) - go back to main menu
                current_menu="main"
                ;;
            "$connected")
                toggle_connection "$mac"
                ;;
            "$paired")
                toggle_paired "$mac"
                ;;
            "$trusted")
                toggle_trust "$mac"
                ;;
            "$goback")
                current_menu="main"
                ;;
        esac
    done
}

# Opens a rofi menu with current bluetooth status and options to connect
show_menu() {
    local current_menu="main"
    
    while [[ $current_menu == "main" ]]; do
        set_rofi_command
        
        # Get menu options
        if power_on; then
            power="Power: on"
            # Human-readable names of devices, one per line
            # If scan is off, will only list paired devices
            devices=$(bluetoothctl devices | grep Device | cut -d ' ' -f 3- | head -15)
            if [[ -z "$devices" ]]; then
                devices="No Saved Devices"
            fi
            # Get controller flags
            scan=$(scan_on)
            pairable=$(pairable_on)
            discoverable=$(discoverable_on)
            # Options passed to rofi
            options="$devices\n$divider\n$power\n$scan\n$pairable\n$discoverable"
        else
            power="Power: off"
            options="$power"
        fi
        
        # Open rofi menu, read chosen option
        chosen="$(echo -e "$options" | $rofi_command "Bluetooth Menu")"
        
        # Match chosen option to command
        case "$chosen" in
            "" | "$divider")
                # Empty selection (Escape key) - exit the script
                current_menu="exit"
                ;;
            "$power")
                toggle_power
                ;;
            "$scan")
                toggle_scan
                ;;
            "$discoverable")
                toggle_discoverable
                ;;
            "$pairable")
                toggle_pairable
                ;;
            *)
                device=$(bluetoothctl devices | grep "$chosen")
                # Open a submenu if a device is selected
                if [[ $device ]]; then 
                    device_menu "$device"
                fi
                ;;
        esac
    done
}

# Main execution
case "$1" in
    --status)
        print_status
        ;;
    *)
        show_menu
        ;;
esac
